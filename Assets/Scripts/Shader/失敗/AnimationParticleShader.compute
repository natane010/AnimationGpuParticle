#pragma kernel UpdatePositionAsAnimation

#include "HLSLSupport.cginc"

struct AnimationTransformParticle
{
    float3 targetPosition;
    float3 position;
    float4 color;
    float scale;
};

uint m_VertCount;

struct SVertInVBO
{
    float3 pos;
    float3 norm;
    float4 tang;
};

struct InVert2Skin
{
    float weight0;
    float weight1;
    float weight2;
    float weight3;
    int index0;
    int index1;
    int index2;
    int index3;
};

RWStructuredBuffer<AnimationTransformParticle> _Particles;

float _DeltaTime;

#define THREADS  64

[numthreads(THREADS, 1, 1)]
void UpdatePositionAsAnimation(uint3 threadID : SV_DispatchThreadID, 
    SAMPLER_UNIFORM StructuredBuffer<SVertInVBO> m_SourceVBO, 
    SAMPLER_UNIFORM StructuredBuffer<InVert2Skin> m_SourceSkin,  
    SAMPLER_UNIFORM StructuredBuffer<float4x4> m_mBones)
{
    const uint t = threadID.x;

    if (t >= m_VertCount)
    {
        return;
    }
    AnimationTransformParticle tp = _Particles[t];
    const SVertInVBO vert = m_SourceVBO[t];
    InVert2Skin si = m_SourceSkin[t];
    float3 vP = vert.pos.xyz;
    float3 vPacc = float3(0,0,0);

    float3 vN = float3(0,0,0);
    vN = vert.norm.xyz;
    float3 vNacc = float3(0,0,0);

    float3 vT = float3(0,0,0);
    vT = vert.tang.xyz;
    float3 vTacc = float3(0,0,0);
    
    vPacc += si.weight0*mul(  m_mBones[si.index0], float4(vP,1) ).xyz;
    vPacc += si.weight1*mul(  m_mBones[si.index1], float4(vP,1) ).xyz;
    vPacc += si.weight2*mul(  m_mBones[si.index2], float4(vP,1) ).xyz;
    vPacc += si.weight3*mul(  m_mBones[si.index3], float4(vP,1) ).xyz;
    
   
    vP = vPacc;
    tp.position = vP;
    //tp.position += (tp.targetPosition - tp.position) * _DeltaTime;

    _Particles[t] = tp;
}
